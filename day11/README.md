day11
==

# 工厂方法设计模式(factory method)

## 概述
定义一个用于创建对象的接口，让子类决定实例化哪一个类。factory method使用一个类的实例化延迟到其子类。

## 应用场景
* 当一个类不知道它所必须创建的对象的类的时候
* 当一个希望由它的子类来指定它所创建的对象的时间点
* 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候

## 示例
[factory method](./src/com/java/www/FactoryMethodTest.java)

## 工厂方法设计总结
FactoryMethod模式是设计模式中应用最为广泛的模式，在面向对象的编程中，对象的创建工作非常简单，对象的创建时机却很重要。FactoryMethod解决的就是这个问题，它通过面向对象的手法，将所要创建的具体对象的创建工作延迟到了子类，从而提供了一种扩展的策略，较好的解决了这种紧耦合的关系。


# 代理模式(proxy)

## 概述
为其他对象提供一种代理以控制对这个对象的访问

## 示例
[proxy model](./src/com/java/www/ProxyTest.java)


# 接口和抽象类的关系
No. |区别 |抽象类 |接口
:---|--- |--- |--- 
1 |定义 |包含一个或以上抽象方法的类 |只含全局常量和抽象方法的集合 
2 |组成 |变量、常量、构造器、抽象方法、普通方法 |常量、抽象方法 
3 |使用 |子类继承抽象类(extends) |子类实现接口(implements)
4 |关系 |抽象类可以实现多个接口 |接口不能继承抽象类，但允许继承多个接口
5 |常见设计模式 |模板设计 |工厂设计、代理设计
6 |对象 |都通过对象的多态性产生实例对象 |同左
7 |局限 |抽象类有单继承的局限 |接口没有此局限 
8 |实际 |作为一个模板 |作为一个标准或一种能力 
9 |选择 |如果用抽象类和接口都完成的，优先使用接口，可避免单继承的局限 |优先
10 |特殊 |一个抽象类中可以包含多个接口 |一个接口中可以包含多个抽象方法 

* 在开发中建议：一个类不要去继承一个已经实现好的类，要么继承抽象类，要么实现接口。


# 类的成员之五：内部类
* 类的内部可以再定义类。外面的类：外部类，里面定义的类：内部类
* 内部类分类
    * 成员内部类（声明在类的方法外）
    * 局部内部类（声明在类的方法里）
* 成员内部类
    * 是外部类的一个成员
        - 可以用修饰符(private、protected、public, default)，外部内只能有public 或default
        - static、final
        - 可以调用外部类的属性方法
    * 具有类的特点
        - 可以指定为 abstract类
        - 可以在其内部定义属性、方法、构造器
* 局部内部类
    * 常用方法：使其返回值为局部内部类或接口的对象。这个类或接口在方法内部创建
    * 没有修饰符
    * 匿名内部类
    

* 内部类重点
    * 如何创建成员内部类的对象
        - 静态成员内部类创建对象
            Person p1 = new Person("钟侃扎", 24);
            Person.Bird b1 = p1.new Bird("Polly", 500);
        - 静态成员内部类创建对象
            Person.Dog d1 = new Person.Dog("皮卡丘", "yello");
    * 如何区分调用外部类、内部类的变量，尤其是重名时
        - 内部类的变量：this.xx,
        - 外部类的变量：外部类.this.xx
    * 局部内部类的使用
    * Inner class的名字不能与包含它的类名相同
    * 非static的内部类中的成员不能声明为static的，只有在外部类或static的内部类中才可声明static成员
    
## 内部类示例
[Inner Class](./src/com/java/www/InnerClassTest.java)


# 匿名内部类
匿名内部类不能定义任何静态成员、方法和类，  只能创建匿名内部类的一个实例。  
一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类

匿名内部示例  
[Anonymous Inner Class](./src/com/java/www/AnonymousInnerClassTest.java)


# 异常
什么是异常
>在java语言中，将程序执行中发生的不正常的情况称为“异常”，  
不包括开发过程中的语法错误和逻辑错误

java.lang.Throwable
## 分类
* Error 错误，程序中不进行处理
>java虚拟机无法解决的严重问题，如JVM系统内部错误，资源耗尽等
* Exception 异常，要求在编写程序时，就要考虑到这些异常的处理
>因其他编程错误或偶然外因导致的一般性问题。如空指针、网络中断等

## Exception
* 编译时异常，在编译期间会出现的异常（执行javac 命令时，出现异常，必须处理（将异常进行捕获，转化为运行时异常），否则编译出错不能运行）
    Exception的子类中除了RuntimeException以外的
* 运行时异常（执行java命令时，出现异常，可不处理）
    RuntimeException的所有子类
    
## 异常解决方法
* 遇到错误就终止程序
* 由程序员在编写程序时，就考虑到错误的检测、错误消息的提示及错误的处理

## 异常特点
* 执行一个程序时，如果出现异常，那么异常后面的代码就不再执行

## java异常类层次
[java异常类层次结构详情](./java异常类层次.md)


## 示例
[异常示例](./src/com/java/exception/ExceptionTest.java)  
[Error](./src/com/java/exception/ErrorTest.java)  
[Error 2](./src/com/java/exception/Error2Test.java)

# 异常处理机制
* 异常处理的抓抛模型
* 异常类对象的生成
    - 由虚拟机自动生成，自动抛出异常
    - 由开发人员手动创建，手动抛出异常
* 如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处理。  
如果异常没有在调用者方法里处理,它继续被抛给这个调用方法的上层方法。  
这个过程将一起继续下去，直到异常被。这个过程被称为捕获异常(catch)
* 如果一个异常回到main()方法，并且main()也不处理，则程序运行终止
* 程序员通常只能处理Exception，而对Error无能为力

## 如何处理异常
* 抛--执行代码时，一旦出现异常，就会在异常的代码处理生成一个应对的异常类的对象，并将此对象抛出（分为自动抛出、手动抛出）
    * 一旦抛出此异常类的对象，程序就终止执行
    * 此异常类的对象抛给方法的调用者(java运行时系统)
* 抓--抓住上一步抛出的异常类的对象。如何抓取
### 方式一
try-catch-finally
```
try {
    // 可能出现异常的代码
} catch(Exception1 e) {
    // 异常1处理方法
} catch(Exception2 e) {
    // 异常2处理方法
} finally {
    // 一定要执行的代码
}

```
### 注意
* finall 是可选的
* try 块内声明的变量为局部变量。出了try { }就不能被调用了
* catch 语句内对异常的处理
    - getMessage()    -- 返回String关键错误信息
    - printStackTrace()    -- 打印异常类名和异常信息，以及异常出现在程序中的位置。返回值void
* 可以多个catch语句，try中抛出的异常类对象从上往下匹配catch中的异常类的类型，一旦匹配就执行catch中的代码
    执行完就跳出后面的catch语句
* 如果异常处理了，其后的代码继续执行
* 对于运行时异常，可以不显式的进行处理；对于编译时异常，必须要显式的进行处理
* 若catch中多个异常类型是"并列"关系，哪个在上都可以
    若catch中多个异常类型是"包含"关系，必须子类异常类放在父类异常类的上面进行处理，否则编译报错。
* finally中的语句一定会被执行。不管try、catch中是否仍有异常未被处理，以及是否有return语句，除了是明确指定退出程序外，如System.exit(1)
* try-catch可以嵌套

### 方式二，声明抛出异常


# java对象在内存中的结构
* 栈(stack)
    - 局部变量
    - 对象的引用名
    - 数组的引用名
* 堆(heap)
    - new出来的对象
* 方法区(method area)
    + 字符串常量池
* 静态域(static area)
    + 存放类中静态的变量

